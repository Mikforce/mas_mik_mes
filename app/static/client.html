<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Family Messenger</title>
    <style>
        /* –í–∞—à–∏ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            padding: 20px;
            background: white;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f0f2f5;
        }

        .message-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .input-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .conversation {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .conversation:hover {
            background: #e9ecef;
        }

        .conversation.active {
            background: #007bff;
            color: white;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 70%;
            word-wrap: break-word;
        }

        .message.own {
            background: #007bff;
            color: white;
            margin-left: auto;
        }

        .message.other {
            background: white;
            border: 1px solid #e9ecef;
        }

        .message-image {
            max-width: 100%;
            border-radius: 10px;
            margin-top: 5px;
        }

        .login-form {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 400px;
        }

        input, textarea, button {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .unread-badge {
            background: #dc3545;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 12px;
            margin-left: 10px;
        }

        .search-result {
            transition: background-color 0.2s;
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .search-result:hover {
            background-color: #f0f0f0;
        }

        .search-result button {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 12px;
            float: right;
        }

        .search-result button:hover {
            background: #218838;
        }

        .file-preview {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px dashed #dee2e6;
        }

        .file-preview img {
            max-width: 100px;
            max-height: 100px;
            border-radius: 5px;
        }

        .file-preview .remove-file {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-left: 10px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .encryption-indicator {
            font-size: 12px;
            color: #28a745;
            margin-top: 5px;
        }

        .message-status {
            font-size: 11px;
            text-align: right;
            margin-top: 3px;
            color: rgba(255, 255, 255, 0.7);
        }

        .message.other .message-status {
            color: rgba(0, 0, 0, 0.5);
        }

        /* –ù–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤ */
        .file-message {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            margin-top: 5px;
        }

        .file-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            word-break: break-all;
        }

        .file-size {
            font-size: 12px;
            color: #666;
        }

        .download-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            margin-left: 10px;
        }

        .download-btn:hover {
            background: #218838;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="login-page" class="login-form">
            <h2>–í—Ö–æ–¥ –≤ Secure Messenger</h2>
            <input type="text" id="username" placeholder="–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è">
            <input type="password" id="password" placeholder="–ü–∞—Ä–æ–ª—å">
            <button onclick="login()">–í–æ–π—Ç–∏</button>
            <button class="btn-secondary" onclick="showRegister()">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</button>
        </div>

        <div id="register-page" class="login-form" style="display: none;">
            <h2>–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</h2>
            <input type="text" id="reg-username" placeholder="–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è">
            <input type="email" id="reg-email" placeholder="Email (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)">
            <input type="password" id="reg-password" placeholder="–ü–∞—Ä–æ–ª—å">
            <button onclick="register()">–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è</button>
            <button class="btn-secondary" onclick="showLogin()">–ù–∞–∑–∞–¥ –∫ –≤—Ö–æ–¥—É</button>
        </div>

        <div id="chat-container" class="container" style="display: none;">
            <div class="sidebar">
                <h3>–î–∏–∞–ª–æ–≥–∏</h3>

                <div style="margin-bottom: 15px;">
                    <input type="text" id="user-search" placeholder="–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π..."
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                    <div id="search-results" style="margin-top: 10px;"></div>
                </div>

                <div id="conversations-list"></div>
            </div>

            <div class="chat-area">
                <div class="chat-header">
                    <h3 id="current-chat">–í—ã–±–µ—Ä–∏—Ç–µ –¥–∏–∞–ª–æ–≥</h3>
                    <span id="connection-status">‚ùå –û—Ç–∫–ª—é—á–µ–Ω</span>
                </div>

                <div class="messages" id="messages-container">
                    <div class="message-info">–í—ã–±–µ—Ä–∏—Ç–µ –¥–∏–∞–ª–æ–≥ –¥–ª—è –Ω–∞—á–∞–ª–∞ –æ–±—â–µ–Ω–∏—è</div>
                </div>

                <div class="message-input">
                    <div id="file-preview" class="file-preview" style="display: none;"></div>
                    <div id="voice-preview" class="file-preview" style="display: none;"></div>
                    <textarea id="message-text" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." rows="3"></textarea>
                    <div class="input-controls">
                        <input type="file" id="file-input" accept="image/*,audio/*, .pdf, .txt" style="display: none;">
                        <button class="btn-secondary" onclick="document.getElementById('file-input').click()">
                            üìé –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–∞–π–ª
                        </button>
                        <button id="voice-toggle" class="btn-secondary" type="button">üéôÔ∏è –ì–æ–ª–æ—Å</button>
                        <button id="send-button" class="btn-success" onclick="sendMessage()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== CRYPTO MANAGER ====================
        class CryptoManager {
            constructor(username) {
                this.username = username;
                this.algOAEP = {
                    name: 'RSA-OAEP',
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: 'SHA-256'
                };
                this.algPSS = {
                    name: 'RSA-PSS',
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: 'SHA-256'
                };
            }

            // ---------- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π ----------
            async generateAllKeys() {
                console.log("üîë –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", this.username);

                // RSA-OAEP (—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ)
                const encPair = await crypto.subtle.generateKey(
                    this.algOAEP, true, ['encrypt', 'decrypt']
                );

                const publicEncPem = this.arrayBufferToPem(
                    await crypto.subtle.exportKey('spki', encPair.publicKey), "PUBLIC"
                );
                const privateEncPem = this.arrayBufferToPem(
                    await crypto.subtle.exportKey('pkcs8', encPair.privateKey), "PRIVATE"
                );

                // RSA-PSS (–ø–æ–¥–ø–∏—Å—å)
                const signPair = await crypto.subtle.generateKey(
                    this.algPSS, true, ['sign', 'verify']
                );

                const publicSignPem = this.arrayBufferToPem(
                    await crypto.subtle.exportKey('spki', signPair.publicKey), "PUBLIC"
                );
                const privateSignPem = this.arrayBufferToPem(
                    await crypto.subtle.exportKey('pkcs8', signPair.privateKey), "PRIVATE"
                );

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
                localStorage.setItem(this.username + "_enc_public", publicEncPem);
                localStorage.setItem(this.username + "_enc_private", privateEncPem);
                localStorage.setItem(this.username + "_sign_public", publicSignPem);
                localStorage.setItem(this.username + "_sign_private", privateSignPem);

                return {
                    encPublic: publicEncPem,
                    encPrivate: privateEncPem,
                    signPublic: publicSignPem,
                    signPrivate: privateSignPem
                };
            }

            // ---------- –ò–º–ø–æ—Ä—Ç –∫–ª—é—á–µ–π ----------
            async importPublicKey(pem, type = "RSA-OAEP") {
                const binaryDer = this.pemToArrayBuffer(pem);
                return await crypto.subtle.importKey(
                    "spki",
                    binaryDer,
                    type === "RSA-OAEP" ? this.algOAEP : this.algPSS,
                    true,
                    type === "RSA-OAEP" ? ["encrypt"] : ["verify"]
                );
            }

            async importPrivateKey(pem, type = "RSA-OAEP") {
                const binaryDer = this.pemToArrayBuffer(pem);
                return await crypto.subtle.importKey(
                    "pkcs8",
                    binaryDer,
                    type === "RSA-OAEP" ? this.algOAEP : this.algPSS,
                    true,
                    type === "RSA-OAEP" ? ["decrypt"] : ["sign"]
                );
            }

            // ---------- –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ / –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ ----------
            async encryptMessage(plaintext, receiverPublicKeyPem) {
                try {
                    console.log("üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è...");

                    // AES-–∫–ª—é—á
                    const aesKey = await crypto.subtle.generateKey(
                        { name: 'AES-GCM', length: 256 },
                        true,
                        ['encrypt', 'decrypt']
                    );
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encoded = new TextEncoder().encode(plaintext);

                    const encryptedData = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv },
                        aesKey,
                        encoded
                    );

                    // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º AES-–∫–ª—é—á
                    const rawAesKey = await crypto.subtle.exportKey("raw", aesKey);

                    // –®–∏—Ñ—Ä—É–µ–º AES-–∫–ª—é—á –ø—É–±–ª–∏—á–Ω—ã–º RSA
                    const receiverPublicKey = await this.importPublicKey(receiverPublicKeyPem, "RSA-OAEP");
                    const encryptedAesKey = await crypto.subtle.encrypt(
                        { name: "RSA-OAEP" },
                        receiverPublicKey,
                        rawAesKey
                    );

                    // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                    const signature = await this.signMessage(plaintext);

                    return {
                        encryptedText: this.arrayBufferToBase64(encryptedData),
                        encryptedKey: this.arrayBufferToBase64(encryptedAesKey),
                        iv: this.arrayBufferToBase64(iv),
                        signature: signature
                    };
                } catch (e) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏:", e);
                    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ");
                }
            }

            async decryptMessage(encryptedTextBase64, encryptedKeyBase64, ivBase64, signatureBase64, senderPublicKeyPem) {
                try {
                    console.log("üîì –ü–æ–ø—ã—Ç–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è");

                    // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
                    this.validateEncryptedData(encryptedTextBase64, encryptedKeyBase64, ivBase64);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
                    const privateKeyPem = localStorage.getItem(this.username + "_enc_private");
                    if (!privateKeyPem) {
                        throw new Error("–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω");
                    }

                    const privateKey = await this.importPrivateKey(privateKeyPem, "RSA-OAEP");

                    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º AES-–∫–ª—é—á
                    const encryptedKeyBuffer = this.base64ToArrayBuffer(encryptedKeyBase64);
                    const decryptedAesKeyBuffer = await crypto.subtle.decrypt(
                        { name: "RSA-OAEP" },
                        privateKey,
                        encryptedKeyBuffer
                    );

                    // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º AES –∫–ª—é—á
                    const aesKey = await crypto.subtle.importKey(
                        "raw",
                        decryptedAesKeyBuffer,
                        { name: "AES-GCM" },
                        false,
                        ["decrypt"]
                    );

                    // –î–µ—à–∏—Ñ—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                    const ivBuffer = this.base64ToArrayBuffer(ivBase64);
                    const encryptedTextBuffer = this.base64ToArrayBuffer(encryptedTextBase64);

                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: ivBuffer },
                        aesKey,
                        encryptedTextBuffer
                    );

                    const plaintext = new TextDecoder().decode(decrypted);

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å –∏ –Ω–µ fallback)
        if (senderPublicKeyPem && signatureBase64 && signatureBase64 !== 'fallback-signature') {
                        try {
                            const valid = await this.verifySignature(plaintext, signatureBase64, senderPublicKeyPem);
                            if (!valid) {
                                console.warn("‚ö†Ô∏è –ü–æ–¥–ø–∏—Å—å —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞");
                    // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞, –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
                    return plaintext;
                            }
                        } catch (signatureError) {
                            console.warn("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏:", signatureError);
                        }
                    }

                    return plaintext;

                } catch (e) {
                    console.error("‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ:", e);

                    // Fallback: –ø–æ–ø—Ä–æ–±—É–µ–º –ø—Ä–æ—Å—Ç–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å base64
                    try {
                        const fallbackText = atob(encryptedTextBase64);
                        return "[Fallback] " + fallbackText;
                    } catch (fallbackError) {
                        throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: " + e.message);
                    }
                }
            }

            // ========== –ú–ï–¢–û–î –î–õ–Ø –®–ò–§–†–û–í–ê–ù–ò–Ø –§–ê–ô–õ–û–í ==========
            async encryptFile(file, receiverPublicKeyPem) {
                try {
                    console.log("üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞...", file.name);

                    // –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª –∫–∞–∫ ArrayBuffer
                    const fileBuffer = await file.arrayBuffer();

                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º AES –∫–ª—é—á
                    const aesKey = await crypto.subtle.generateKey(
                        { name: 'AES-GCM', length: 256 },
                        true,
                        ['encrypt', 'decrypt']
                    );

                    const iv = crypto.getRandomValues(new Uint8Array(12));

                    // –®–∏—Ñ—Ä—É–µ–º —Ñ–∞–π–ª
                    const encryptedData = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv },
                        aesKey,
                        fileBuffer
                    );

                    // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º AES –∫–ª—é—á
                    const rawAesKey = await crypto.subtle.exportKey("raw", aesKey);

                    // –®–∏—Ñ—Ä—É–µ–º AES –∫–ª—é—á –ø—É–±–ª–∏—á–Ω—ã–º –∫–ª—é—á–æ–º –ø–æ–ª—É—á–∞—Ç–µ–ª—è
                    const receiverPublicKey = await this.importPublicKey(receiverPublicKeyPem, "RSA-OAEP");
                    const encryptedAesKey = await crypto.subtle.encrypt(
                        { name: "RSA-OAEP" },
                        receiverPublicKey,
                        rawAesKey
                    );

                    // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    const signature = await this.signMessage(this.arrayBufferToBase64(encryptedData));

                    return {
                        encryptedData: this.arrayBufferToBase64(encryptedData),
                        encryptedKey: this.arrayBufferToBase64(encryptedAesKey),
                        iv: this.arrayBufferToBase64(iv),
                        signature: signature,
                        filename: file.name,
                        fileType: file.type,
                        fileSize: file.size
                    };
                } catch (e) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞:", e);
                    // Fallback: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º base64 —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –±–µ–∑ E2EE (–¥–µ–º–æ)
                    const fileBuffer = await file.arrayBuffer();
                    const base64Data = this.arrayBufferToBase64(fileBuffer);
                    return {
                        encryptedData: base64Data,
                        encryptedKey: 'fallback-key',
                        iv: 'fallback-iv',
                        signature: 'fallback-signature',
                        filename: file.name,
                        fileType: file.type,
                        fileSize: file.size
                    };
                }
            }

            // ========== –ú–ï–¢–û–î –î–õ–Ø –†–ê–°–®–ò–§–†–û–í–ö–ò –§–ê–ô–õ–û–í ==========
            async decryptFile(encryptedDataBase64, encryptedKeyBase64, ivBase64, signatureBase64, senderPublicKeyPem) {
                try {
                    console.log("üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ —Ñ–∞–π–ª–∞...");

                    // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
                    this.validateEncryptedData(encryptedDataBase64, encryptedKeyBase64, ivBase64);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
                    const privateKeyPem = localStorage.getItem(this.username + "_enc_private");
                    if (!privateKeyPem) {
                        throw new Error("–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω");
                    }

                    const privateKey = await this.importPrivateKey(privateKeyPem, "RSA-OAEP");

                    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º AES –∫–ª—é—á
                    const encryptedKeyBuffer = this.base64ToArrayBuffer(encryptedKeyBase64);
                    const decryptedAesKeyBuffer = await crypto.subtle.decrypt(
                        { name: "RSA-OAEP" },
                        privateKey,
                        encryptedKeyBuffer
                    );

                    // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º AES –∫–ª—é—á
                    const aesKey = await crypto.subtle.importKey(
                        "raw",
                        decryptedAesKeyBuffer,
                        { name: "AES-GCM" },
                        false,
                        ["decrypt"]
                    );

                    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Ñ–∞–π–ª
                    const ivBuffer = this.base64ToArrayBuffer(ivBase64);
                    const encryptedDataBuffer = this.base64ToArrayBuffer(encryptedDataBase64);

                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: ivBuffer },
                        aesKey,
                        encryptedDataBuffer
                    );

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
                    if (senderPublicKeyPem && signatureBase64) {
                        try {
                            const valid = await this.verifySignature(
                                this.arrayBufferToBase64(encryptedDataBuffer),
                                signatureBase64,
                                senderPublicKeyPem
                            );
                            if (!valid) {
                                console.warn("‚ö†Ô∏è –ü–æ–¥–ø–∏—Å—å —Ñ–∞–π–ª–∞ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞");
                            }
                        } catch (signatureError) {
                            console.warn("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏ —Ñ–∞–π–ª–∞:", signatureError);
                        }
                    }

                    return new Blob([decrypted]);
                } catch (e) {
                    console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ —Ñ–∞–π–ª–∞:", e);
                    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª: " + e.message);
                }
            }

            // ---------- –ü–æ–¥–ø–∏—Å—å / –ü—Ä–æ–≤–µ—Ä–∫–∞ ----------
            async signMessage(message) {
                try {
                    const privateSignPem = localStorage.getItem(this.username + "_sign_private");
                    const privateKey = await this.importPrivateKey(privateSignPem, "RSA-PSS");

                    const data = new TextEncoder().encode(message);

                    const signature = await crypto.subtle.sign(
                        { name: "RSA-PSS", saltLength: 32 },
                        privateKey,
                        data
                    );

                    return this.arrayBufferToBase64(signature);
                } catch (e) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∞–Ω–∏–∏:", e);
                    return "signature-error";
                }
            }

            async verifySignature(message, signatureBase64, publicKeyPem) {
                try {
                    const publicKey = await this.importPublicKey(publicKeyPem, "RSA-PSS");
                    const data = new TextEncoder().encode(message);

                    return await crypto.subtle.verify(
                        { name: "RSA-PSS", saltLength: 32 },
                        publicKey,
                        this.base64ToArrayBuffer(signatureBase64),
                        data
                    );
                } catch (e) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–¥–ø–∏—Å–∏:", e);
                    return false;
                }
            }

            // ---------- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ ----------
            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                const chunkSize = 0x8000; // 32KB
                let binary = '';
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                return btoa(binary);
            }

            base64ToArrayBuffer(base64) {
                try {
                    const cleanedBase64 = base64.replace(/\s+/g, '').replace(/[^A-Za-z0-9+/=]/g, '');

                    if (cleanedBase64.length % 4 !== 0) {
                        console.warn('Base64 —Å—Ç—Ä–æ–∫–∞ –∏–º–µ–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é –¥–ª–∏–Ω—É, –¥–æ–±–∞–≤–ª—è–µ–º padding');
                        const paddedBase64 = cleanedBase64 + '='.repeat((4 - cleanedBase64.length % 4) % 4);
                        return this.rawBase64ToArrayBuffer(paddedBase64);
                    }

                    return this.rawBase64ToArrayBuffer(cleanedBase64);
                } catch (e) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è base64:', e);
                    throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç base64 –¥–∞–Ω–Ω—ã—Ö: ' + e.message);
                }
            }

            rawBase64ToArrayBuffer(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes.buffer;
            }

            arrayBufferToPem(arrayBuffer, type) {
                const base64 = this.arrayBufferToBase64(arrayBuffer);
                const pemHeader = `-----BEGIN ${type} KEY-----\n`;
                const pemFooter = `\n-----END ${type} KEY-----`;
                const body = base64.match(/.{1,64}/g).join("\n");
                return pemHeader + body + pemFooter;
            }

            pemToArrayBuffer(pem) {
                const b64 = pem.replace(/-----[^-]+-----/g, "").replace(/\s+/g, "");
                return this.base64ToArrayBuffer(b64);
            }

            validateEncryptedData(encryptedTextBase64, encryptedKeyBase64, ivBase64) {
                const requiredFields = [
                    { name: 'encryptedText', value: encryptedTextBase64 },
                    { name: 'encryptedKey', value: encryptedKeyBase64 },
                    { name: 'iv', value: ivBase64 }
                ];

                for (const field of requiredFields) {
                    if (!field.value || typeof field.value !== 'string') {
                        throw new Error(`–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ: ${field.name}`);
                    }

                    if (field.value.trim().length === 0) {
                        throw new Error(`–ü—É—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è: ${field.name}`);
                    }

                    if (!/^[A-Za-z0-9+/]*={0,2}$/.test(field.value.replace(/\s+/g, ''))) {
                        throw new Error(`–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç base64 –≤ –ø–æ–ª–µ: ${field.name}`);
                    }
                }
            }
        }

        // ==================== APPLICATION CODE ====================
        let currentUser = null;
        let currentToken = null;
        let websocket = null;
        let currentConversation = null;
        let cryptoManager = null;
        let allUsers = [];
        let currentFile = null; // –î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞

        // ==================== FILE HANDLING ====================
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ (–º–∞–∫—Å–∏–º—É–º 10MB)
            if (file.size > 10 * 1024 * 1024) {
                alert('–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 10MB');
                return;
            }

            currentFile = file;
            showFilePreview(file);
        });

        function showFilePreview(file) {
            const previewContainer = document.getElementById('file-preview');
            const reader = new FileReader();

            reader.onload = function(e) {
                let previewHTML = '';

                if (file.type.startsWith('image/')) {
                    previewHTML = `<img src="${e.target.result}" alt="Preview" style="max-width: 60px; max-height: 60px;">`;
                } else {
                    previewHTML = `<div style="font-size: 24px;">üìÑ</div>`;
                }

                previewContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center;">
                            ${previewHTML}
                            <div style="margin-left: 10px;">
                                <div>${file.name}</div>
                                <div style="font-size: 12px; color: #666;">${(file.size / 1024).toFixed(1)} KB</div>
                            </div>
                        </div>
                        <button class="remove-file" onclick="removeFile()">√ó</button>
                    </div>
                `;
                previewContainer.style.display = 'block';
            };

            reader.readAsDataURL(file);
        }

        function removeFile() {
            currentFile = null;
            document.getElementById('file-preview').style.display = 'none';
            document.getElementById('file-input').value = '';
        }

        // ==================== API FUNCTIONS ====================
        async function apiCall(endpoint, options = {}) {
            try {
                const response = await fetch(`http://localhost:8000${endpoint}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': currentToken ? `Bearer ${currentToken}` : '',
                    },
                    ...options
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error ${response.status}: ${errorText}`);
                }

                return response.json();
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        // ==================== CRYPTO FUNCTIONS ====================
        async function encryptMessage(text, receiverPublicKey) {
            ensureCryptoManager();
            try {
                console.log('Encrypting message for:', receiverPublicKey.substring(0, 50) + '...');
                const encryptedData = await cryptoManager.encryptMessage(text, receiverPublicKey);
                console.log('Message encrypted successfully');
                return encryptedData;
            } catch (error) {
                console.error('Error encrypting message:', error);
                return {
                    encryptedText: btoa(unescape(encodeURIComponent(text))),
                    encryptedKey: 'fallback-key',
                    iv: 'fallback-iv',
                    signature: 'fallback-signature'
                };
            }
        }

        async function decryptMessage(encryptedTextBase64, encryptedKeyBase64, ivBase64, signatureBase64, senderPublicKeyBase64) {
            ensureCryptoManager();
            try {
                console.log('Decrypting message...');
                const decryptedText = await cryptoManager.decryptMessage(
                    encryptedTextBase64,
                    encryptedKeyBase64,
                    ivBase64,
                    signatureBase64,
                    senderPublicKeyBase64
                );
                console.log('Message decrypted successfully');
                return decryptedText;
            } catch (error) {
                console.error('Error decrypting message:', error);
                return '–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: ' + error.message;
            }
        }

        function ensureCryptoManager() {
            if (!cryptoManager) {
                throw new Error('CryptoManager not initialized. Please login first.');
            }
        }

        // ==================== FILE UPLOAD ====================
        async function uploadFile() {
            if (!currentFile || !currentConversation) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –∏ –ø–æ–ª—É—á–∞—Ç–µ–ª—è');
                return null;
            }

            try {
                console.log('–ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞...');

                // –ü–æ–ª—É—á–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –ø–æ–ª—É—á–∞—Ç–µ–ª—è
                const receiverKeyInfo = await apiCall(`/users/${currentConversation}/public-key`);
                console.log('–ü–æ–ª—É—á–µ–Ω –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –ø–æ–ª—É—á–∞—Ç–µ–ª—è');

                // –®–∏—Ñ—Ä—É–µ–º —Ñ–∞–π–ª —Å fallback
                let encryptedData;
                try {
                    encryptedData = await cryptoManager.encryptFile(currentFile, receiverKeyInfo.public_key);
                } catch (encErr) {
                    console.warn('encryptFile failed, using base64 fallback:', encErr);
                    const buf = await currentFile.arrayBuffer();
                    const base64 = cryptoManager.arrayBufferToBase64(buf);
                    encryptedData = {
                        encryptedData: base64,
                        encryptedKey: 'fallback-key',
                        iv: 'fallback-iv',
                        signature: 'fallback-signature',
                        filename: currentFile.name,
                        fileType: currentFile.type,
                        fileSize: currentFile.size
                    };
                }
                console.log('–§–∞–π–ª –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω');

                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                const response = await fetch('http://localhost:8000/files/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: JSON.stringify({
                        filename: encryptedData.filename,
                        file_type: encryptedData.fileType,
                        file_size: encryptedData.fileSize,
                        encrypted_data: encryptedData.encryptedData,
                        encrypted_key: encryptedData.encryptedKey,
                        iv: encryptedData.iv,
                        signature: encryptedData.signature,
                        receiver_username: currentConversation
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞');
                }

                const fileResponse = await response.json();
                console.log('–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω:', fileResponse);

                // –û—á–∏—â–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ñ–∞–π–ª
                removeFile();

                return fileResponse;

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞:', error);
                alert('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
                return null;
            }
        }

        // ==================== FILE DOWNLOAD AND DISPLAY ====================
        async function downloadFile(fileId, filename) {
            try {
                const fileData = await apiCall(`/files/download/${fileId}`);
                let blob;
                if (fileData.encrypted_key === 'fallback-key') {
                    // –§–∞–π–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –±–µ–∑ E2EE (fallback) ‚Äî –ø—Ä–æ—Å—Ç–æ –¥–µ–∫–æ–¥–∏—Ä—É–µ–º base64
                    const bytes = cryptoManager.base64ToArrayBuffer(fileData.encrypted_data);
                    blob = new Blob([bytes], { type: fileData.file_type || 'application/octet-stream' });
                } else {
                    // –ü–æ–ª—É—á–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
                    const senderKeyInfo = await apiCall(`/users/${fileData.sender_id}/public-key`);

                    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Ñ–∞–π–ª
                    blob = await cryptoManager.decryptFile(
                        fileData.encrypted_data,
                        fileData.encrypted_key,
                        fileData.iv,
                        fileData.signature,
                        senderKeyInfo.public_key
                    );
                }

                // –°–æ–∑–¥–∞–µ–º URL –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename || fileData.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞:', error);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª: ' + error.message);
            }
        }

        async function viewImage(fileId, filename) {
            try {
                const fileData = await apiCall(`/files/download/${fileId}`);
                let blob;
                if (fileData.encrypted_key === 'fallback-key') {
                    // –§–∞–π–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –±–µ–∑ E2EE (fallback) ‚Äî –ø—Ä–æ—Å—Ç–æ –¥–µ–∫–æ–¥–∏—Ä—É–µ–º base64
                    const bytes = cryptoManager.base64ToArrayBuffer(fileData.encrypted_data);
                    blob = new Blob([bytes], { type: fileData.file_type || 'image/*' });
                } else {
                    // –ü–æ–ª—É—á–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
                    const senderKeyInfo = await apiCall(`/users/${fileData.sender_id}/public-key`);

                    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Ñ–∞–π–ª
                    blob = await cryptoManager.decryptFile(
                        fileData.encrypted_data,
                        fileData.encrypted_key,
                        fileData.iv,
                        fileData.signature,
                        senderKeyInfo.public_key
                    );
                }

                const url = URL.createObjectURL(blob);

                // –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–µ–≤—å—é –¥–ª—è —ç—Ç–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
                const preview = document.querySelector(`.image-preview[data-file-id="${fileId}"]`);
                if (preview) {
                    preview.innerHTML = '';
                    const img = document.createElement('img');
                    img.src = url;
                    img.alt = filename || 'image';
                    img.style.maxWidth = '260px';
                    img.style.borderRadius = '8px';
                    img.onload = () => {
                        // URL –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ–∑–∂–µ, –æ—Å—Ç–∞–≤–∏–º –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ–∫–∞–∑–∞
                    };
                    preview.appendChild(img);
                } else {
                    // Fallback: –ø—Ä–æ—Å—Ç–æ –æ—Ç–∫—Ä—ã—Ç—å –≤ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ
                    window.open(url, '_blank');
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ' + error.message);
            }
        }

        async function playAudio(fileId, filename) {
            try {
                const fileData = await apiCall(`/files/download/${fileId}`);
                let blob;
                if (fileData.encrypted_key === 'fallback-key') {
                    const bytes = cryptoManager.base64ToArrayBuffer(fileData.encrypted_data);
                    blob = new Blob([bytes], { type: fileData.file_type || 'audio/webm' });
                } else {
                    const senderKeyInfo = await apiCall(`/users/${fileData.sender_id}/public-key`);
                    blob = await cryptoManager.decryptFile(
                        fileData.encrypted_data,
                        fileData.encrypted_key,
                        fileData.iv,
                        fileData.signature,
                        senderKeyInfo.public_key
                    );
                }

                const url = URL.createObjectURL(blob);
                const preview = document.querySelector(`.audio-preview[data-file-id="${fileId}"]`);
                if (preview) {
                    preview.innerHTML = '';
                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = url;
                    audio.style.width = '260px';
                    preview.appendChild(audio);
                    audio.play().catch(() => {});
                } else {
                    const audio = new Audio(url);
                    audio.play();
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ:', error);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∞—É–¥–∏–æ: ' + error.message);
            }
        }

        // ==================== MODIFIED SEND MESSAGE ====================
        async function sendMessage() {
            const text = document.getElementById('message-text').value;
            const sendButton = document.getElementById('send-button');

            sendButton.innerHTML = '<span class="loading"></span>';
            sendButton.disabled = true;

            try {
                // –ï—Å–ª–∏ –µ—Å—Ç—å —Ñ–∞–π–ª, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ –≤–º–µ—Å—Ç–æ —Ç–µ–∫—Å—Ç–∞
                if (currentFile) {
                    const fileResponse = await uploadFile();
                    if (fileResponse) {
                        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
                        await loadMessages(currentConversation);
                        await loadConversations();
                    }
                }
                // –ï—Å–ª–∏ –µ—Å—Ç—å –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ
                else if (currentVoiceBlob) {
                    const voiceResponse = await uploadVoice();
                    if (voiceResponse) {
                        await loadMessages(currentConversation);
                        await loadConversations();
                    }
                }
                // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—Å—Ç, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                else if (text.trim()) {
                    if (!currentConversation) {
                        alert('–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è');
                        return;
                    }

                    console.log('Starting message sending process...');

                    // Get receiver's public key
                    const receiverKeyInfo = await apiCall(`/users/${currentConversation}/public-key`);
                    console.log('Got receiver public key');

                    // Encrypt message
                    const encryptedData = await encryptMessage(text, receiverKeyInfo.public_key);
                    console.log('Message encrypted');

                    // Send to server
                    await apiCall('/messages/send', {
                        method: 'POST',
                        body: JSON.stringify({
                            receiver_username: currentConversation,
                            encrypted_text: encryptedData.encryptedText,
                            encrypted_key: encryptedData.encryptedKey,
                            iv: encryptedData.iv,
                            signature: encryptedData.signature
                        })
                    });
                    console.log('Message sent successfully');

                    // Clear input and update UI
                    document.getElementById('message-text').value = '';
                    await loadMessages(currentConversation);
                    await loadConversations();
                }
            } catch (error) {
                console.error('Error sending message:', error);
                alert('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ' + error.message);
            } finally {
                sendButton.innerHTML = '–û—Ç–ø—Ä–∞–≤–∏—Ç—å';
                sendButton.disabled = false;
            }
        }

        // ==================== WEBSOCKET FUNCTIONS ====================
        function connectWebSocket() {
            if (websocket) {
                websocket.close();
            }

            websocket = new WebSocket(`ws://localhost:8000/ws?token=${currentToken}`);

            websocket.onopen = function() {
                console.log('WebSocket connected');
                updateConnectionStatus('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω');
            };

            websocket.onmessage = async function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('WebSocket message received:', data);

                    if (data.type === 'new_message') {
                        if (data.message.sender_username === currentConversation ||
                            data.message.receiver_username === currentUser) {
                            await loadMessages(currentConversation);
                            await loadConversations();
                        }
                    } else if (data.type === 'file_uploaded') {
                        if (data.file.receiver_username === currentUser ||
                            data.file.sender_username === currentConversation) {
                            await loadMessages(currentConversation);
                            await loadConversations();
                        }
                    }
                } catch (error) {
                    console.error('Error processing WebSocket message:', error);
                }
            };

            websocket.onclose = function() {
                console.log('WebSocket disconnected');
                updateConnectionStatus('‚ùå –û—Ç–∫–ª—é—á–µ–Ω');
                // Try to reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };

            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateConnectionStatus('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
            };
        }

        function updateConnectionStatus(status) {
            document.getElementById('connection-status').textContent = status;
        }

        // ==================== UI FUNCTIONS ====================
        function showLogin() {
            document.getElementById('login-page').style.display = 'block';
            document.getElementById('register-page').style.display = 'none';
        }

        function showRegister() {
            document.getElementById('login-page').style.display = 'none';
            document.getElementById('register-page').style.display = 'block';
        }

        async function login() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            try {
                const response = await apiCall('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ username, password })
                });

                currentUser = username;
                currentToken = response.access_token;
                cryptoManager = new CryptoManager(username);

                // Check if keys exist, generate if not
                if (!localStorage.getItem(username + "_enc_private")) {
                    await cryptoManager.generateAllKeys();
                    console.log('New keys generated for user:', username);
                }

                // Show chat interface
                document.getElementById('login-page').style.display = 'none';
                document.getElementById('chat-container').style.display = 'flex';

                // Load data
                await loadConversations();
                await loadAllUsers();
                connectWebSocket();

            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: ' + error.message);
            }
        }

        async function register() {
            const username = document.getElementById('reg-username').value;
            const email = document.getElementById('reg-email').value;
            const password = document.getElementById('reg-password').value;

            try {
                await apiCall('/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ username, email, password })
                });

                alert('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞! –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ–π—Ç–∏.');
                showLogin();

            } catch (error) {
                alert('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ' + error.message);
            }
        }

        // ==================== CONVERSATION FUNCTIONS ====================
        async function loadConversations() {
            try {
                const conversations = await apiCall('/conversations');
                const container = document.getElementById('conversations-list');

                container.innerHTML = '';

                conversations.forEach(conv => {
                    const div = document.createElement('div');
                    div.className = `conversation ${currentConversation === conv.username ? 'active' : ''}`;
                    div.innerHTML = `
                        <strong>${conv.username}</strong>
                        ${conv.unread_count > 0 ? `<span class="unread-badge">${conv.unread_count}</span>` : ''}
                        <div style="font-size: 12px; color: #666;">${conv.last_message || '–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π'}</div>
                    `;
                    div.onclick = () => selectConversation(conv.username);
                    container.appendChild(div);
                });

            } catch (error) {
                console.error('Error loading conversations:', error);
            }
        }

        async function selectConversation(username) {
            currentConversation = username;
            document.getElementById('current-chat').textContent = username;

            // Update active conversation in sidebar
            document.querySelectorAll('.conversation').forEach(conv => {
                conv.classList.remove('active');
            });
            document.querySelectorAll('.conversation').forEach(conv => {
                if (conv.textContent.includes(username)) {
                    conv.classList.add('active');
                }
            });

            await loadMessages(username);

            // Mark as read
            try {
                await apiCall(`/conversations/${username}/read`, {
                    method: 'POST'
                });
                await loadConversations();
            } catch (error) {
                console.error('Error marking as read:', error);
            }
        }

        // ==================== MESSAGE FUNCTIONS ====================
        async function loadMessages(username) {
            try {
                const messages = await apiCall(`/messages/${username}`);
                // –û–±–µ—Å–ø–µ—á–∏–º –ø–æ—Ä—è–¥–æ–∫: —Å—Ç–∞—Ä—ã–µ —Å–≤–µ—Ä—Ö—É, –Ω–æ–≤—ã–µ —Å–Ω–∏–∑—É
                messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const container = document.getElementById('messages-container');

                container.innerHTML = '';

                if (messages.length === 0) {
                    container.innerHTML = '<div class="message-info">–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π</div>';
                    return;
                }

                for (const msg of messages) {
                    await displayMessage(msg);
                }

                // Scroll to bottom
                container.scrollTop = container.scrollHeight;

            } catch (error) {
                console.error('Error loading messages:', error);
                document.getElementById('messages-container').innerHTML =
                    '<div class="message-info">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π</div>';
            }
        }

        async function displayMessage(msg) {
            const container = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');

            const isOwn = msg.sender_username === currentUser;
            messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;

            try {
                let content = '';

                if (msg.file_id) {
                    // –≠—Ç–æ —Ñ–∞–π–ª
                    const isImage = (msg.file_type || '').startsWith('image');
                    const isAudio = (msg.file_type || '').startsWith('audio') || /\.(webm|mp3|wav|m4a)$/i.test(msg.file_name || '');
                    content = `
                        <div class="file-message" id="message-file-${msg.file_id}">
                            <div class="file-icon">${isImage ? 'üñºÔ∏è' : (isAudio ? 'üéß' : 'üìÑ')}</div>
                            <div class="file-info">
                                <div class="file-name">${msg.file_name}</div>
                                <div class="file-size">${(msg.file_size / 1024).toFixed(1)} KB</div>
                            </div>
                            <div class="file-actions">
                                ${isImage ? `<button class="download-btn" onclick="viewImage('${msg.file_id}', '${msg.file_name}')">–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å</button>` : ''}
                                ${isAudio ? `<button class="download-btn" onclick="playAudio('${msg.file_id}', '${msg.file_name}')">–ü—Ä–æ—Å–ª—É—à–∞—Ç—å</button>` : ''}
                                <button class="download-btn" onclick="downloadFile('${msg.file_id}', '${msg.file_name}')">–°–∫–∞—á–∞—Ç—å</button>
                            </div>
                            ${isImage ? `<div class="image-preview" data-file-id="${msg.file_id}" style="margin-top:8px;"></div>` : ''}
                            ${isAudio ? `<div class="audio-preview" data-file-id="${msg.file_id}" style="margin-top:8px;"></div>` : ''}
                        </div>
                    `;
                } else {
                    // –≠—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                    let decryptedText = await decryptMessage(
                        msg.encrypted_text,
                        msg.encrypted_key,
                        msg.iv,
                        msg.signature,
                        msg.sender_public_key
                    );

                    content = `
                        <div>${decryptedText}</div>
                        <div class="encryption-indicator">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ</div>
                    `;
                }

                messageDiv.innerHTML = content + `
                    <div class="message-status">
                        ${new Date(msg.timestamp).toLocaleTimeString()}
                        ${isOwn ? '‚úì' : ''}
                    </div>
                `;

            } catch (error) {
                console.error('Error displaying message:', error);
                messageDiv.innerHTML = `
                    <div>–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è</div>
                    <div class="message-status">
                        ${new Date(msg.timestamp).toLocaleTimeString()}
                    </div>
                `;
            }

            container.appendChild(messageDiv);
        }

        // ==================== USER SEARCH FUNCTIONS ====================
        async function loadAllUsers() {
            try {
                allUsers = await apiCall('/users');

                // Setup search functionality
                document.getElementById('user-search').addEventListener('input', function(e) {
                    const searchTerm = e.target.value.toLowerCase();
                    const resultsContainer = document.getElementById('search-results');

                    resultsContainer.innerHTML = '';

                    if (searchTerm.length < 2) return;

                    const filteredUsers = allUsers.filter(user =>
                        user.username.toLowerCase().includes(searchTerm) &&
                        user.username !== currentUser
                    );

                    filteredUsers.forEach(user => {
                        const div = document.createElement('div');
                        div.className = 'search-result';
                        div.innerHTML = `
                            <span>${user.username}</span>
                            <button onclick="startConversation('${user.username}')">–ù–∞–ø–∏—Å–∞—Ç—å</button>
                        `;
                        resultsContainer.appendChild(div);
                    });
                });

            } catch (error) {
                console.error('Error loading users:', error);
            }
        }

        async function startConversation(username) {
            // Clear search
            document.getElementById('user-search').value = '';
            document.getElementById('search-results').innerHTML = '';

            await selectConversation(username);
        }

        // ==================== INITIALIZATION ====================
        // Check if user is already logged in
        window.onload = function() {
            const savedToken = localStorage.getItem('auth_token');
            const savedUser = localStorage.getItem('current_user');

            if (savedToken && savedUser) {
                currentToken = savedToken;
                currentUser = savedUser;
                cryptoManager = new CryptoManager(savedUser);

                document.getElementById('login-page').style.display = 'none';
                document.getElementById('chat-container').style.display = 'flex';

                loadConversations();
                loadAllUsers();
                connectWebSocket();
            }
        };

        // Save token on login
        if (currentToken) {
            localStorage.setItem('auth_token', currentToken);
            localStorage.setItem('current_user', currentUser);
        }

        // ==================== VOICE MESSAGE ====================
        let mediaRecorder = null;
        let voiceChunks = [];
        let currentVoiceBlob = null;

        document.getElementById('voice-toggle').addEventListener('click', async () => {
            const btn = document.getElementById('voice-toggle');
            try {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                    voiceChunks = [];
                    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) voiceChunks.push(e.data); };
                    mediaRecorder.onstop = () => {
                        currentVoiceBlob = new Blob(voiceChunks, { type: 'audio/webm' });
                        const url = URL.createObjectURL(currentVoiceBlob);
                        const prev = document.getElementById('voice-preview');
                        prev.style.display = 'block';
                        prev.innerHTML = '';
                        const audio = document.createElement('audio');
                        audio.controls = true;
                        audio.src = url;
                        prev.appendChild(audio);
                    };
                    mediaRecorder.start();
                    btn.textContent = '‚èπÔ∏è –°—Ç–æ–ø';
                } else if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    btn.textContent = 'üéôÔ∏è –ì–æ–ª–æ—Å';
                }
            } catch (e) {
                console.error('Voice recording error:', e);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É');
            }
        });

        async function uploadVoice() {
            if (!currentVoiceBlob || !currentConversation) return null;
            // –°–æ–∑–¥–∞–µ–º File –æ–±—ä–µ–∫—Ç –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è uploadFile –ª–æ–≥–∏–∫–∏
            const voiceFile = new File([currentVoiceBlob], `voice_${Date.now()}.webm`, { type: 'audio/webm' });
            // –ü–æ–¥—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ currentFile –∏ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º uploadFile
            const prevCurrent = currentFile;
            currentFile = voiceFile;
            try {
                const res = await uploadFile();
                return res;
            } finally {
                currentFile = prevCurrent;
                currentVoiceBlob = null;
                document.getElementById('voice-preview').style.display = 'none';
                document.getElementById('voice-preview').innerHTML = '';
            }
        }

    </script>
</body>
</html>
